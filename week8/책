```python
# while 문으로 작성한 선형 알고리즘

from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:    # 
    """시퀀스 a에서 key와 값이 같은 원소를 선형 검색(while문)"""

    i = 0

    while True:
        if i == len(a):
            return -1         # 검색에 실패하여 -1 반환
        if a[i] == key:
            return i        # 검색에 성공하여 현재 검사한 배열의 인덱스 반환
        i += 1

if __name__ == '__main__':
    num = int(input('원소 수를 입력하시오 '))  # num값 입력받음
    X = [None] * num                         # 원소 수가 num인 배열 생성

    for i in range(num):
        X[i] = int(input(f'X[{i}]: '))

        ky = int(input('검색할 값을 입력하시오'))  # 검색할 키 ky를 입력받음

        idx = seq_search(X, ky)                 # ky와 값이 같은 원소를 X에서 검색

        if idx == -1:
            print('검색값을 갖는 원소가 존재하지 않음')
        else:
            print(f'검색값은 x[{idx}]에 있다')
```

- **seq_search( )**는 배열 a에서 값이 key인 원소를 선형 검색하는 함수, 찾은 원소의 인덱스 반환
- 값이 key인 원소가 여러 개 존재하는 경우 맨 처음 발견한 원소 반환, 배열 안에 값이 key인 원소가 없으면 -1 반환

```python
# for 문으로 작성한 선형 알고리즘

from typing import Any, Sequence

def seq_search(a: Sequence, key: Any) -> int:    
    """시퀀스 a에서 key와 값이 같은 원소를 선형 검색(for문)"""
    for i in range(len(a)):
        if a[i] == key:
            return i    # 검색 성공(인덱스 반환)
        return -1       # 검색 실패(-1 반환)

if __name__ == '__main__':  # 현재 스크립트가 직접 실행되었을 떄만 그 안의 블록을 실행
    num = int(input('원소 수를 입력하시오 '))  # num값 입력받음
    X = [None] * num                         # 원소 수가 num인 배열 생성

    for i in range(num):
        X[i] = int(input(f'X[{i}]: '))

        ky = int(input('검색할 값을 입력하시오'))  # 검색할 키 ky를 입력받음

        idx = seq_search(X, ky)                 # ky와 값이 같은 원소를 X에서 검색

        if idx == -1:
            print('검색값을 갖는 원소가 존재하지 않음')
        else:
            print(f'검색값은 X[{idx}]에 있다')
```

- while문을 for문으로 구현하면 코드가 더 짧고 간결해짐

```python
# seq_search() 함수 사용하여 실수 검색하기
from ssearch_while import seq_search

print('실수 검색')
print('주의: "End"입력시 종료됨')

number = 0
X = []          # 빈 리스트 X 생성

while True:
    s = input(f'[{number}]:')
    if s == 'End':
        break
    X.append(float(s))  # 배열 맨 끝에 원소 추가
    number += 1

ky = float(input('검색할 값 입력')) # 검색할 키 ky 입력받기

idx = seq_search(X, ky)    # ky와 값이 같은 원소를 X에서 검색
if idx == -1:
    print('검색할 값을 갖는 원소가 존재하지 않음')
else:
    print(f'검색값은 X[{idx}]에 있음')
```

- seq_search( ) 함수로 임의의 자료형인 시퀀스에서 검색 가능
- float형인 실수(부동 소수점 수) 배열에서 검색

```python
# seq_search()함수를 사용해 특정 인덱스 검색

from ssearch_while import seq_search

t = (4, 6, 5.6, 2, 3.14, 1)
s = 'string'
a = ['DTS', 'AAC', 'FLAC']

print(f'{t}에서 5.6의 인덱스는 {seq_search(t, 5.6)}이다')
print(f'{s}에서 "n"의 인덱스는 {seq_search(s,"n")}이다')
print(f'{a}에서 "DTS"의 인덱스는 {seq_search(a, "DTS")}이다')
```

- 튜플 t에 int형 정수와 float형 실수 원소가 있으나 검색 가능
- str형 문자열 s 안에서 문자 검색 가능(시퀀스 이므로)
- a는 문자열 배열이지만, 검색 가능(모든 원소가 str형이고 list형 리스트)

```python
# 선형 검색 알고리즘(실습 3-1)을 보초법으로 수정

from typing import Any, Sequence
import copy

def seq_search(seq: Sequence, key: Any) -> int:
    """시퀀스 seq에서 key와 일치하는 원소를 선형 검색(보초법)"""
    a = copy.deepcopy(seq)   # seq 복사
    a.append(key)            # 보초 key 추가

    i = 0
    while True:
        if a[i] == key:
            break            # 검색 성공하면 while문 종료
        i += 1
    return -1 if i == len(seq) else i

if __name__ == '__main__':
    num = int(input('원소 수 입력'))  # num 값 입력
    X = [None] * num                # 원소 수가 num인 배열 생성

    for i in range(num):
        X[i] = int(input(f'X[{i}]: '))   

    ky = int(input('검색할 값 입력'))        # 검색할 키 ky 입력받기

    idx = seq_search(X, ky)                # 키 ky값과 같은 원소를 X에서 검색

    if idx == -1:
        print('검색값을 갖는 원소 존재X')
    else:
        print(f'검색값은 x[{idx}]에 있음')
```

- 배열 seq를 a로 복사, a의 마지막 보초 key 추가(원래 배열 맨 끝에 보초를 추가한 새로운 배열)
- 배열 원소 스캔하여 검색하는 과정 반복
