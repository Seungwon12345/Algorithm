배열

배열 - 묶음 단위로 값을 저장하는 자료구조
원소 - 배열에 저장된 객체 하나하나
변수로 해결하기 어려운 문제를 배열로 보완하면 프로그래밍을 효율적으로 할 수 있음(배열 원소의 자료형은 int, float형 등 어떤 것도 상관없음)

리스트,튜플

파이썬에서는 배열을 리스트와 튜플로 구현 가능(리스트와 튜플은 데이터 컨테이너라고 함)

리스트 				vs 	튜플
원소 변경 가능(뮤터블) 			원소 변경 불가능(이뮤터블)

리스트

```python
list01 = [] -> [] 원소 없이 []만 사용하면 빈 리스트 생성, 빈 리스트
list02 = [1, 2, 3] -> [1, 2, 3]
list03 = ['A', 'B', 'C', ] -> ['A', 'B', 'C', ] 맨마지막 원소에 , 써도 됨
```

```python
list() 사용하면 문자열, 튜플 등 다양한 자료형 객체를 원소로 하는 리스트 생성 가능

list04 = list() 빈 리스트 생성
list05 = list('ABC') # ['A', 'B', 'C'] 문자열의 각 문자로부터 원소 생성
list06 = list([1, 2, 3]) # [1, 2, 3] 리스트로부터 원소 생성
list07 = list((1, 2, 3)) # [1, 2, 3] 튜플로 부터 원소 생성
```

```python
특정 범위 리스트(range(), list()) 함수 조합 사용)

list09 = list(range(7)) # [0, 1, 2, 3, 4, 5, 6]
list10 = list(range(3, 8)) # [3, 4, 5, 6, 7]
list11 = list(range(3, 13, 2) # [3, 5, 7, 9, 11]     
range(a, b, step) -> a부터 b-1까지 step 간격으로 증가하는 수열
```

```python
원소가 5개이면서 원솟값이 없는 리스트

ist12 = [None] * 4 [None, None, None, None] 
리스트의 원소 개수는 리스트 만들기 전에 반드시 결정(원솟값을 정하지 않으면 None를 사용해 만들수 있음)
```

튜플

```python
원소에 순서를 매겨 결합한 것 -> 원소 변경 불가(이뮤터블)
원소를 , 로 구분하여 나열한 뒤 ( )로 둗러싸는 방식으로 생성

tuple01 = ( ) # ( ) 빈 튜플
tuple02 = 1, # (1, )         * 원소가 1개인 경우 원소 뒤에 쉼표를 반드시 입력(입력 안하면 변수로 여김)
tuple03 = (1, ) # (1, )
tuple04 = 1, 2, 3 # (1, 2, 3)
tuple05 = 1, 2, 3, # (1, 2, 3)
tuple06 = (1, 2, 3) # (1, 2, 3)
tuple07 = (1, 2, 3, ) # (1, 2, 3)
tuple08 =  'A', 'B', 'C' # ('A', 'B', 'C')
```

```python
* 원소가 1개인 경우 원소 뒤에 쉼표를 반드시 입력(입력 안하면 변수로 여김) *

v01 = 1 # 튜플x 하나의 값을 가진 정수형 변수
v02 = (1) # 튜플x 하나의 값을 가진 정수형 변수
```

```python
tuple() 사용하면 문자열, 리스트 등 여러 자료형 객체를 원소로하는 튜플 생성가능

tuple09 = tuple() # ( )빈 튜플
tuple10 = tuple('ABC') # ('A', 'B', 'C') 문자열의 각 문자로부터 원소 생성
tuple11 = tuple([1, 2, 3]) # (1, 2, 3) 리스트로부터 원소 생성 tuple([ ])
tuple12 = tuple({1, 2, 3}) # (1, 2, 3) 집합으로부터 원소 생성 tuple({ })
```

```python
특정 범위의 값을 원소로 갖는 튜플

tuple13 = tuple(range(5)) # (0, 1, 2, 3, 4)
tuple14 = tuple(range(2, 5)) # (2, 3, 4)
tuple15 = tuple(range((2, 11, 4)) # (2, 6, 10)
```

```python
언팩 - 리스트, 튜플의 원솟값들을 풀어 여러 변수에 대입하는 것
x = [1, 2, 3] # 리스트 x 선언
a, b, c = x # x를 언팩하여 변수 a, b, c에 대입
a, b, c # (1, 2, 3)
```

인덱스로 원소에 접근

리스트나 튜플의 원소에 접근할떄 인덱스 사용

인덱스식

```python
x = [2, 3, 5, 6, 23]
x[2] = 5 # 리스트 x의 앞에서 3번째 원소
x[-4] = 2 # 리스트 x의 뒤에서 5번쨰 원소
x[-3] = 4.58 # 리스트 x의 뒤에서 4번째 원소에 새로운 값 대입(자동 형 변환 정수형(int)-> 실수형(float)) 값 자체 복사X, 객체의 식별 번호 변경(3 -> 4.58)
x[8] = 5.98 => 오류, 존재하지 않는 원소에 접근하거나 대입해도 원소가 새롭게 추가X
```

슬라이스식
슬라이스 - 리스트, 튜플의 원소 일부를 연속, 일정한 간격으로 꺼내 새로운 리스트, 튜플을 만드는 것

```python
s[i:j] -> s[i]부터 s[j-1]까지 나열
s[i:j:k] -> s[i]부터 s[j-1]까지 k씩 건너뛰며 나열

s = [2, 34, 53, 244, 983]
s[1:3] # 리스트 s의 1번재 원소부터 2번쨰 원소 출력
=> [34, 53]
s[-1:-3] # 리스트의 s의 뒤에서 1번째 원소부터 4번째 원소까지 출력
=> [983, 244, 53, 34]
s[3:1] # 리스트 s의 j값(1)이 i값(3)보다 작아도 오류 안생김
=> [] # start에서 end까지 앞으로 갈 수 있는 요소 없으므로 빈리스트 [] 반환
```

s[i:j:k] i j k  지정 규칙

- 인덱스와 달리 범위에서 벗어나는 값을 지정해도 오류 안남 ⇒ [ ] 반환
- i가 없거나 None ⇒ 0으로 간주
- j가 없거나 None ⇒ len(s) 리스트 길이로 자동 설정

| 슬라이싱 표현식 | 설명 | 예시 코드 | 결과 |
| --- | --- | --- | --- |
| `s[:]` | 리스트 전체 출력 | `s[:]` | `[2, 4, 5, 3, 152]` |
| `s[:n]` | 처음부터 인덱스 n-1까지 출력 | `s[:2]` | `[2, 4]` |
| `s[i:]` | 인덱스 i부터 끝까지 출력 | `s[2:]` | `[5, 3, 152]` |
| `s[-n:]` | 뒤에서 n번째 원소부터 끝까지 출력 | `s[-2:]` | `[3, 152]` |
| `s[::k]` | 처음부터 k개씩 건너뛰며 출력 | `s[::2]` | `[2, 5, 152]` |
| `s[::-1]` | 리스트를 거꾸로 출력 | `s[::-1]` | `[152, 3, 5, 4, 2]` |

뮤터블, 이뮤터블 대입

- 변수에 값이 저장되어 있어도 다른 값 대입 가능 ⇒ 값 변경되면 값을 참조하는 객체의  식별 번호 변경

```python
n = 5 # n에 5 대입
id(n) # id() 함수로 객체 식별번호 출력
65416984
n = 'abc' # n에 문자열 'abc' 대입
id(n) # id() 함수로 객체 고윳값 출력
54684984 # 함수 식별 번호 변경
```

뮤터블 자료형 - 값 변경 가능(리스트, 딕셔너리, 집합 등)

이뮤터블 자료형 - 값 변경 불가능(수, 문자열, 튜플 등)

파이썬의 대입

- 변수에 맞는 자료형을 자동으로 선언해줌
- 대입식은 값 자체가 X, 객체의 식별번호 대입
- 여러 변수에 여러 값 한꺼번에 대입 가능

자료구조

데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계 

ex) 리스트와 튜플은 자료구조에 포함시켜 배열이라 할 수 있음

len( ) 함수

```python
리스트나 튜플의 원소 수(배열의 길이) => len() 함수로 구할 수 있음

s = [15, 56, 87, 489, [15,59], 'ehdfu']
len(s)
6

원소 자체가 리스트(집합, 튜플)인 경우 1개의 원소로 계산
```

배열 판단

- 빈 배열 판단

```python
if x:
			# x가 비어있지 않으면(True) 실행
else:
			# x가 비어있으면(False) 실행
```

- 대소, 등가 판단(True인 예)

```python
[1, 2, 3] == [1, 2, 3]
[1, 3, 5] < [1, 4, 6]
[3, 5, 6] < [3, 5, 6, 10]
[1, 2, 3] < [1, 3, 5, 6] < [1, 4, 7, 8, 6]

맨 앞 원소부터 차례로 비교하고 원소 값이 같으면 다음 원소 비교
원소의 값이 크면 큰 원소가 큰 배열로 판단
배열의 원소 수가 다르면 원소 수가 많은 배열 크다고 판단
```

- 등가성 비교는 좌변, 우변의 값이 같은지 비교
- 동일성 비교는 값, 객체 식별번호까지 비교

리스트, 튜플 공통점

| 항목 | 설명 |
| --- | --- |
| 자료 저장 | 여러 개의 데이터를 하나의 변수에 저장 가능 |
| 인덱싱/슬라이싱 | 인덱스를 이용한 접근과 슬라이싱 가능 (`[0]`, `[1:3]` 등) |
| 반복 가능 | `for`, `while` 등을 통해 반복문 사용 가능 |
| 다양한 자료형 저장 | 정수, 문자열, 리스트 등 혼합된 자료형 저장 가능 |
| 길이 확인 | `len()` 함수를 사용해 원소 개수 확인 가능 |

리스트, 튜플 차이점

| 항목 | 리스트 (`list`) | 튜플 (`tuple`) |
| --- | --- | --- |
| **가변성** | ✅ 변경 가능 (`append`, `remove` 등) | ❌ 변경 불가 (생성 후 수정/삭제 불가) |
| **사용할 때** | 내용이 바뀔 가능성이 있을 때 | 내용이 고정되어야 할 때 |
| **속도** | 느림 (가변성 때문에 메모리 관리가 필요) | 빠름 (불변이므로 더 가볍고 효율적) |
| **메서드** | `append()`, `pop()`, `sort()` 등 다양 | 메서드 제한적 (`count()`, `index()` 등) |
| **표기 방식** | 대괄호 사용: `[1, 2, 3]` | 소괄호 사용: `(1, 2, 3)` |

내포 표기 생성

리스트 안에서 새로운 리스트 생성하는 기법

```python
numbers = [1, 2, 3, 5, 6]
twice = [num * 2 for num in numbers if num % 2 == 1]
print(twice)

=> [2, 6, 10]
```

배열

실습2-2 

```python
# 시퀀스 원소의 최댓값 출력하기

from typing import Any, Sequence # 시퀀스 자료형(순서가 있는, 리스트형, 바이트 배열형, 문자열형, 튜플형)
																 # 임의의 자료형(int, float 등)

def max_of(a: Sequence) -> Any:  # 함수에 전달되는 a의 자료형은 Sequence, 반환하는 자료형은 어느 타입이든(Any)
    """시퀀스형 a 원소의 최댓값 반환""" # a: Sequence => 함수 어노테이션
    maximum = a[0]              # max_of()함수 안에서 배열 a의 원솟값 변경X
    for i in range(1, len(a)):  # 호출하는 쪽이 넘겨주는 실제 인수 자료형은 스퀀스 형이면 상관 없음(뮤터블 리스트, 이뮤터블 튜플또는문자열 등)
        if a[i] > maximum:      # 원소를 ">"(비교연산자)로 값을 비교 가능하면 자료형이 달라도 됨
            maximum = a[i]      # 최댓값의 자료형 값으로 반환
    return maximum
    
if __name__ == '__main__':       # 파일이 직접 실행 되었을 때만 아래 코드 실행
    print('배열의 최댓값을 구함')
    num = int(input('원소 수 입력: '))
    x = [None] * num # 원소 수가 num인 리스트 생성

    for i in range(num):
        x[i] = int(input(f'x[{i}]값 입력: '))

    print(f'최댓값은 {max_of(x)}')
```

모듈

파이썬에서 하나의 스크립트 프로그램

ex) max.py의 모듈 이름은 max

if __name__ == '__main__’

⇒ __name__과 '__main__’ 같은지 판단 , __name__ ⇒ 모듈 이름 나타내는 변수

- 스크립트 프로그램이 직접 실행될 떄 변수 __name__은  '__main__’
- 스크립트 프로그램이 임포트 될 때 변수 __name__은 원래의 모듈 이름

모듈 테스트

실습2-3

```python
# 배열 원소의 최댓값을 구해서 출력하기(원솟값 입력받음)

from max import max_of   # 모듈 max로 정의된  max_of 함수 사용하도록 임포트

print('배열의 최댓값 구함')
print('주의: "End" 입력시 종료')

number = 0
x = []

while True:
    s = input(f'x[{number}]값 입력: ')
    if s == 'End':
        break
    x.append(int(s)) # 배열 맨 끝 추가
    number += 1

print(f'{number}개 입력함')
print(f'최댓값은 {max_of(x)}')
```

실습2-4

```python
# 배열 원소의 최댓값을 구해서 출력하기(원솟값 난수로 생성)

import random
from max import max_of

print('난수 최댓값 구함')
num = int(input('난수 개수 입력: '))
lo = int(input('난수 최솟값 입력: '))
hi = int(input('난수 최댓값 입력: '))
x = [None] * num  # 원소 수가 num인 리스트 생성

for i in range(num):
    x[i] = random.randint(lo, hi)  # lo 이상 hi 이하 난수 반환

print(f'{(x)}')
print(f'이 가운데 최댓값은 {max_of(x)}')
```
