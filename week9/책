**이진 검색**

- 원소가 오름차순이나 내림차순으로 정렬된 배열에서 좀 더 효율적으로 검색할 수 있는 알고리즘

```python
# 이진 검색 알고리즘

from typing import Any, Sequence

def bin_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 일치하는 원소를 이진 검색"""
    pl = 0          # 검색 범위 맨 앞 원소의 인덱스
    pr = len(a) - 1 # 검색 범위 맨 끝 원소의 인덱스

    while True:
        pc = (pl + pr) // 2 # 중앙 원소의 인덱스
        if a[pc] == key:
            return pc  # 검색 성공
    
        elif a[pc] < key:
            pl = pc + 1 # 검색 범위를 뒤쪽 절반으로 좁힘
        else:
            pr = pc - 1 # 검색 밤위를 앞쪽 절반으로 좁힘
        if pl > pr:
            break
    return -1   # 검색 실패
    
if __name__ == '__main__':
    num = int(input('원소 수 입력'))
    x = [None] * num        # 원소 수가 num인 배열 생성

    print('배열 데이터 오름차순으로 입력')

    x[0] = int(input('x[0]: '))

    for i in range(1, num):
        while True:
            x[i] = int(input(f'x[{i}]: '))
            if x[i] >= x[i - 1]:    # 바로 직전에 입력한 원솟값보다 큰 값 입력
                break

    ky = int(input('검색할 값 입력')) # 검색할 키 값 ky 입력

    idx = bin_search(x, ky)     # ky값과 같은 원소를 x에서 검색

    if idx == -1:
        print('검색값을 갖는 원소 존재 안함')
    else:
        print(f'검색값은 x[{idx}]에 있음')
```

- 이진 검색 → 검색 대상 배열이 오름차순 정렬되어 있어야 함
- 바로 앞에 입력한 원소보다 큰 값을 받도록(작은 값을 입력하면 다시 입력 받도록)
- 이진 검색 알고리즘은 반복할 때마다 검색 범위가 절반으로 줄어듬(필요한 비교횟수 log n)
- 검색 실패 시 ⌈log(n+1)⌉번, 성공 시 logn -1 번(⌈x⌉ → 크거나 같은 정수 중 가장 작은 수**,** ⌈3.5⌉ = 4)

**복잡도**

- 알고리즘 성능을 객관적으로 평가하는 기준
- 시간 복잡도: 실행하는 데 필요한 시간 평가
- 공간 복잡도: 메모리와 파일 공간이 얼마나 필요한지 평가

```python
# 선형 검색 시간 복잡도

def seq_search(a: Sequence, key: Any) -> int:
1 ---- i = 0
	
2 ---- while i < n:
3 ----	   if a[i] == key:
4 ----        	return i
5	----     i += 1
				
6 ---- return -1
```

| 단계 | 실행 횟수 | 복잡도 |
| --- | --- | --- |
| 1 | 1 | O(1) |
| 2 | n / 2 | O(n) |
| 3 | n / 2 | O(n) |
| 4 | 1 | O(1) |
| 5 | n / 2 | O(n) |
| 6 | 1 | O(1) |
- 복잡도 ⇒  O(f(n)) + O(g(n)) = O(max(f(n), g(n))
- 선형 검색 알고리즘 복잡도(O(n))
- O(n) = O(1) + O(n) + O(n) + O(1) + O(n) + O(1) = O(max(1, n, n, 1, n, 1))

index( ) 함수로 검색하기

obj.index(x, i, j)

obj[i: j] 안에 x와 값이 같은 원소가 있으면 그 중 가장 작은 인덱스 반환, 같은 값이 없으면 예외 처리(ValueError)  

```python
# 이진 검색 시간 복잡도

def bin_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 일치하는 원소를 이진 검색"""
1 ---- pl = 0          
2 ---- pr = len(a) - 1 

        while True:
3 ----     pc = (pl + pr) // 2 
4 ----     if a[pc] == key:
5 ----          return pc 
    
6 ----     elif a[pc] < key:
7 ----          pl = pc + 1 
           else:
8 ----          pr = pc - 1 
9 ----     if pl > pr:
            break
10 ---- return -1   
	
```

| 단계 | 실행 횟수 | 복잡도 |
| --- | --- | --- |
| 1 | 1 | O(1) |
| 2 | 1 | O(1) |
| 3 | log n | O(log n) |
| 4 | log n | O(log n) |
| 5 | 1 | O(1) |
| 6 | log n | O(log n) |
| 7 | log n | O(log n) |
| 8 | log n | O(log n) |
| 9 | log n | O(log n) |
| 10 | 1 | O(1) |

이진 검색 알고리즘 복잡도(O(log n))

O(log n) = O(1) + O(1) + O(log n) + O(log n) + O(1) + … + O(1)

```python
# 복잡도와 증가율

작다                                                          크다
<--------------------------------------------------------------->
1     log n     n     n log n     n**2     n**3     n**k     2**n    
```

- 수가 클수록 알고리즘의 실행 시간이 길어지고 복잡도 증가

```python
# 이진 검색 알고리즘 실행 과정 출력

from typing import Any, Sequence

def bin_search(a: Sequence, key: Any) -> int:
    """시퀀스 a에서 key와 일치하는 원소를 이진 검색(실행 과정 출력)"""
    pl = 0              # 검색 범위 맨 앞 원소 인덱스
    pr = len(a) - 1     # 검색 범위 맨 끝 원소 인덱스

    print('   |', end='')
    for i in range(len(a)):
        print(f'{i : 4}', end='')
    print()
    print('---+' + (4 * len(a) + 2) * '-')

    while True:
        pc = (pl + pr) // 2  # 중앙 원소 인덱스

        print('   |', end='')
        if pl != pc:         # pl 원소 위에 <- 출력  *4 -> 4자리수 맞춰 표시  시작점과 중앙점이 다른 위치에 있을 때
            print((pl * 4 + 1) * ' ' + '<-' + ((pc - pl) * 4) * ' ' + '+', end='') # 인덱스에 화살표를 맞추기 위해 필요한 공백 계산, pl과 pc 사이의 간격을 맞추기 위한 공백 계산
        else:
            print((pc * 4 + 1) * ' ' + '<+', end='') # pl과 pc가 같은 위치 일떄
        if pc != pr:         # pr 원소 위에 -> 출력
            print(((pr - pc) * 4 - 2) * ' ' + '->')
        else:
            print('->')
        print(f'{pc:3}|', end='')
        for i in range(len(a)):
            print(f'{a[i]:4}', end='')
        print('\n   |')
        if a[pc] == key:
            return pc  # 검색 성공
    
        elif a[pc] < key:
            pl = pc + 1 # 검색 범위를 뒤쪽 절반으로 좁힘
        else:
            pr = pc - 1 # 검색 밤위를 앞쪽 절반으로 좁힘
        if pl > pr:
            break
    return -1   # 검색 실패
    
if __name__ == '__main__':
    num = int(input('원소 수 입력'))
    x = [None] * num        # 원소 수가 num인 배열 생성

    print('배열 데이터 오름차순으로 입력')

    x[0] = int(input('x[0]: '))

    for i in range(1, num):
        while True:
            x[i] = int(input(f'x[{i}]: '))
            if x[i] >= x[i - 1]:    # 바로 직전에 입력한 원솟값보다 큰 값 입력
                break

    ky = int(input('검색할 값 입력')) # 검색할 키 값 ky 입력

    idx = bin_search(x, ky)     # ky값과 같은 원소를 x에서 검색

    if idx == -1:
        print('검색값을 갖는 원소 존재 안함')
    else:
        print(f'검색값은 x[{idx}]에 있음')
```

**해시법**

- ‘데이터를 저장할 위치 = 인덱스’ → 간단한 연산으로 구하는 것(원소의 검색, 추가, 삭제 효율적으로 수행 가능)

| 키 | 5 | 6 | 14 | 20 | 29 | 34 |
| --- | --- | --- | --- | --- | --- | --- |
| 해시값(13으로 나눈 나머지) | 5 | 6 | 1 | 7 | 3 | 8 |
- 해시 함수 → 키를 해시값으로 변환하는 과정
- 해시 테이블 → 구한 해시값을 인덱스로 새로 저장한 배열
- 버킷 → 해시 테이블에서 만들어진 원소

**해시 충돌**

- 저장할 버킷이 중복되는 현상(키와 해시값이 꼭 1:1 대응일 필요는 없음, 보통 n:1)
- 체인법: 해시값이 같은 원소를 연결 리스트로 관리
- 오픈 주소법: 빈 버킷을 찾을 떄까지 해시 반복
